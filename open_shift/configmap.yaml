apiVersion: v1
kind: ConfigMap
metadata:
  name: app-scripts
data:
  # (קוד השרת והוורקר ללא שינוי - הועתק מהגרסה התקינה)
  sftp_server.py: |
    import os
    import paramiko
    import threading
    import socket
    import sys
    import time
    import logging

    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger("sftp-server")
    
    HOST_KEY_PATH = '/tmp/host.key'
    PORT = 2222
    DATA_DIR = '/data'

    if not os.path.exists(HOST_KEY_PATH):
        key = paramiko.RSAKey.generate(2048)
        key.write_private_key_file(HOST_KEY_PATH)

    class LocalFileHandle(paramiko.SFTPHandle):
        def __init__(self, flags, path, mode):
            super().__init__(flags)
            self._path = path
            self._file = open(path, mode)
        def close(self):
            if not self._file.closed:
                self._file.close()
                logger.info(f"Closed file: {self._path}")
            super().close()
        def read(self, offset, length):
            self._file.seek(offset)
            return self._file.read(length)
        def write(self, offset, data):
            self._file.seek(offset)
            self._file.write(data)
            return paramiko.SFTP_OK
        def stat(self):
            try: return paramiko.SFTPAttributes.from_stat(os.fstat(self._file.fileno()))
            except OSError: return paramiko.SFTP_FAILURE

    class LocalSFTPServerInterface(paramiko.SFTPServerInterface):
        def _resolve(self, path):
            if path == '/' or path == '.': return DATA_DIR
            if path.startswith('/'): path = path[1:]
            return os.path.join(DATA_DIR, os.path.basename(path))
        def list_folder(self, path):
            path = self._resolve(path)
            try: return [paramiko.SFTPAttributes.from_stat(os.stat(os.path.join(path, f)), f) for f in os.listdir(path)]
            except OSError: return paramiko.SFTP_FAILURE
        def stat(self, path):
            try: return paramiko.SFTPAttributes.from_stat(os.stat(self._resolve(path)))
            except OSError: return paramiko.SFTP_NO_SUCH_FILE
        def lstat(self, path): return self.stat(path)
        def open(self, path, flags, attr):
            full_path = self._resolve(path)
            logger.info(f"Opening file request: {path}")
            try:
                mode = 'rb'
                if (flags & os.O_WRONLY) or (flags & os.O_RDWR): mode = 'wb'
                if flags & os.O_APPEND: mode = 'ab'
                return LocalFileHandle(flags, full_path, mode)
            except OSError as e:
                logger.error(f"Failed to open {full_path}: {e}")
                return paramiko.SFTP_FAILURE
        def remove(self, path):
            try: 
                full_path = self._resolve(path)
                os.remove(full_path)
                logger.info(f"Deleted file: {full_path}")
                return paramiko.SFTP_OK
            except OSError: return paramiko.SFTP_FAILURE
        def rename(self, oldpath, newpath):
            try:
                real_old = self._resolve(oldpath)
                real_new = self._resolve(newpath)
                os.rename(real_old, real_new)
                logger.info(f"Renamed: {oldpath} -> {newpath}")
                return paramiko.SFTP_OK
            except OSError: return paramiko.SFTP_FAILURE

    class StubServer(paramiko.ServerInterface):
        def check_channel_request(self, kind, chanid):
            return paramiko.OPEN_SUCCEEDED if kind == 'session' else paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED
        def check_auth_password(self, username, password):
            return paramiko.AUTH_SUCCESSFUL
        def get_allowed_auths(self, username):
            return 'password'

    def handle_client(conn, addr):
        logger.info(f"New connection from {addr}")
        transport = None
        try:
            transport = paramiko.Transport(conn)
            transport.add_server_key(paramiko.RSAKey(filename=HOST_KEY_PATH))
            transport.set_subsystem_handler('sftp', paramiko.SFTPServer, sftp_si=LocalSFTPServerInterface)
            server = StubServer()
            transport.start_server(server=server)
            channel = transport.accept(20)
            if channel:
                while transport.is_active(): time.sleep(1)
        except Exception as e: logger.error(f"Handler error: {e}")
        finally: 
            if transport: transport.close()

    def start_server():
        if not os.path.exists(DATA_DIR): os.makedirs(DATA_DIR)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('0.0.0.0', PORT))
        s.listen(10)
        logger.info(f"SFTP Listening on {PORT}...")
        while True:
            try:
                conn, addr = s.accept()
                t = threading.Thread(target=handle_client, args=(conn, addr))
                t.daemon = True
                t.start()
            except Exception as e: logger.error(f"Accept error: {e}")

    if __name__ == "__main__": start_server()

  worker.py: |
    import os
    import time
    import sys

    sys.stdout.reconfigure(line_buffering=True)
    WATCH_DIR = "/data"
    print(f"Worker watching {WATCH_DIR}...")

    while True:
        try:
            if not os.path.exists(WATCH_DIR):
                time.sleep(2)
                continue

            for filename in os.listdir(WATCH_DIR):
                if filename.startswith("processed_"): continue
                filepath = os.path.join(WATCH_DIR, filename)
                if os.path.isdir(filepath): continue
                try:
                    stats = os.stat(filepath)
                    if time.time() - stats.st_mtime < 1.5: continue
                except FileNotFoundError: continue 
                
                print(f"Found stable file: {filename}")
                with open(filepath, 'r') as f: content = f.read()
                out_path = os.path.join(WATCH_DIR, f"processed_{filename}")
                with open(out_path, 'w') as f:
                    f.write(f"PROCESSED:\n{content}")
                os.remove(filepath)
                print(f"Processed: {filename}")
        except Exception as e:
            print(f"Error: {e}")
        time.sleep(0.5)
